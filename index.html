<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fourier Flow | Systematic Learning</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MathJax for LaTeX Rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                packages: {'[+]': ['ams']} 
            },
            svg: { fontCache: 'global' },
            startup: {
                typeset: false
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        bg: '#050505',
                        surface: '#111',
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@200;300;500;600&family=JetBrains+Mono:wght@300&display=swap');

        body {
            background-color: #050505;
            color: #e5e5e5;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        /* Page Transition */
        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.6s ease-in-out;
            z-index: 0;
            overflow: hidden;
        }
        .page.active {
            opacity: 1;
            pointer-events: auto;
            z-index: 1;
        }
        
        /* Knowledge Page Scroll */
        #page-knowledge {
            overflow-y: auto;
            padding-top: 100px;
            padding-bottom: 100px;
        }

        .glass-panel {
            background: rgba(15, 15, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .nav-item {
            position: relative;
            opacity: 0.5;
            transition: opacity 0.3s;
            cursor: pointer;
        }
        .nav-item.active {
            opacity: 1;
        }
        .nav-item.active::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 100%;
            height: 1px;
            background: #fff;
        }

        /* Canvas */
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        #canvas-wave { z-index: 0; }
        #canvas-trail { z-index: 5; pointer-events: none; }
        #canvas-draw { z-index: 10; }

        /* Inputs */
        input[type=number], input[type=range] { accent-color: white; }
        input[type=number] {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            outline: none;
        }
        
        /* Flip Card */
        .flip-card {
            background-color: transparent;
            perspective: 1000px;
            height: 420px; /* Increased height for content */
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: left;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
        }

        .flip-card-front {
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            justify-content: space-between;
        }
        .flip-card-front:hover {
            border-color: rgba(255,255,255,0.3);
            background: rgba(30, 30, 30, 0.9);
        }

        .flip-card-back {
            background: #0f0f0f;
            transform: rotateY(180deg);
            overflow-y: auto;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.8);
            justify-content: space-between;
        }

        /* Modal Lesson */
        #lesson-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        #lesson-modal.open {
            opacity: 1;
            pointer-events: auto;
        }
        
        .lesson-content {
            background: #0a0a0a;
            width: 90%;
            max-width: 900px;
            height: 90%;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.15);
            padding: 40px;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
            transform: translateY(20px);
            transition: transform 0.4s ease;
        }
        #lesson-modal.open .lesson-content {
            transform: translateY(0);
        }

        .btn-learn {
            margin-top: 10px;
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            text-align: center;
            font-size: 12px;
            letter-spacing: 1px;
            color: white;
            background: linear-gradient(45deg, rgba(255,255,255,0.05), rgba(255,255,255,0.1));
            transition: all 0.3s;
        }
        .btn-learn:hover {
            background: white;
            color: black;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }

        /* Lesson Typography */
        .lesson-body h3 { color: #fff; font-size: 1.4rem; font-weight: 600; margin-top: 2.5rem; margin-bottom: 1rem; border-left: 4px solid #fff; padding-left: 1rem; letter-spacing: 0.05em; }
        .lesson-body h4 { color: #d4d4d4; font-size: 1.1rem; font-weight: 500; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .lesson-body p { color: #a3a3a3; margin-bottom: 1rem; line-height: 1.8; font-weight: 300; font-size: 1.05rem; }
        .lesson-body ul { list-style-type: disc; padding-left: 1.5rem; margin-bottom: 1.5rem; color: #a3a3a3; }
        .lesson-body li { margin-bottom: 0.5rem; }
        .lesson-body .math-block { 
            background: #111; 
            padding: 1.5rem; 
            border-radius: 8px; 
            margin: 2rem 0; 
            overflow-x: auto; 
            text-align: center; 
            border: 1px solid #333;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .lesson-body .highlight { 
            background: rgba(59, 130, 246, 0.05); 
            border-left: 3px solid #3b82f6; 
            padding: 1.5rem; 
            margin: 2rem 0; 
            color: #dbeafe; 
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #050505; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    </style>
</head>
<body class="font-sans selection:bg-white selection:text-black">

    <!-- Navigation -->
    <nav class="fixed top-0 left-0 w-full z-50 px-8 py-6 flex justify-between items-center mix-blend-difference pointer-events-none">
        <div class="text-xl font-light tracking-[0.2em] uppercase pointer-events-auto">
            Fourier<span class="font-bold">Flow</span>
        </div>
        <div class="flex gap-8 text-xs tracking-widest font-mono pointer-events-auto bg-black/50 backdrop-blur-md px-6 py-2 rounded-full border border-white/10">
            <div onclick="showPage('home')" id="nav-home" class="nav-item active">VISUALIZER</div>
            <div onclick="showPage('knowledge')" id="nav-knowledge" class="nav-item">KNOWLEDGE</div>
            <div onclick="showPage('studio')" id="nav-studio" class="nav-item">STUDIO</div>
        </div>
    </nav>

    <!-- Modal for Lessons -->
    <div id="lesson-modal">
        <div class="lesson-content">
            <button onclick="closeLesson()" class="fixed top-6 right-6 text-gray-500 hover:text-white text-2xl z-50 w-10 h-10 bg-black/50 rounded-full backdrop-blur flex items-center justify-center border border-white/10 transition-all hover:bg-white/20">✕</button>
            <div id="lesson-body" class="lesson-body pb-20">
                <!-- Content injected by JS -->
            </div>
        </div>
    </div>

    <!-- PAGE 1: HOME -->
    <section id="page-home" class="page active">
        <canvas id="canvas-wave" class="canvas-layer"></canvas>
        <div class="absolute top-1/2 left-10 md:left-20 transform -translate-y-1/2 pointer-events-none mix-blend-difference">
            <h1 class="text-6xl md:text-8xl font-thin tracking-tighter mb-4 leading-none">Math<br>is Art</h1>
            <p class="text-xs md:text-sm text-gray-400 font-mono tracking-widest max-w-xs leading-relaxed">Deconstructing reality into circles.</p>
        </div>
        <div class="absolute bottom-10 right-10 glass-panel p-6 rounded-lg w-64">
            <div class="flex justify-between text-xs text-gray-400 mb-4 tracking-widest"><span>HARMONICS</span><span id="wave-n-display">5</span></div>
            <input type="range" id="wave-slider" class="w-full mb-4" min="1" max="50" value="5">
            <div class="flex gap-2">
                <button onclick="setWaveType('square')" class="flex-1 py-2 text-[10px] border border-white/10 hover:bg-white/10 transition rounded text-white">SQ</button>
                <button onclick="setWaveType('sawtooth')" class="flex-1 py-2 text-[10px] border border-white/10 hover:bg-white/10 transition rounded text-white">SAW</button>
                <button onclick="setWaveType('triangle')" class="flex-1 py-2 text-[10px] border border-white/10 hover:bg-white/10 transition rounded text-white">TRI</button>
            </div>
        </div>
    </section>

    <!-- PAGE 2: KNOWLEDGE CARDS -->
    <section id="page-knowledge" class="page">
        <div class="container mx-auto px-6 pb-20">
            <div class="text-center mb-20">
                <h2 class="text-4xl font-light mb-4">傅立葉變換 <span class="font-bold">系統課程</span></h2>
                <p class="text-gray-400 text-sm font-mono tracking-widest uppercase">A 8-Lesson Journey</p>
            </div>

            <!-- Phase 1 -->
            <div class="max-w-6xl mx-auto mb-16">
                <div class="flex items-center gap-4 mb-8 border-b border-white/10 pb-4">
                    <span class="text-4xl font-thin text-white/20">01</span>
                    <div>
                        <h3 class="text-lg font-bold text-white tracking-widest">幾何與基礎</h3>
                        <p class="text-xs text-gray-500 font-mono">建立直觀 (Building Intuition)</p>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Lesson 1 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-blue-400 mb-4">LESSON 01</div>
                                <h3 class="text-2xl font-bold mb-2">函數空間與正交性</h3>
                                <p class="text-sm text-gray-400 mt-2">Geometry of Functions</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">無限維空間中的向量</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-4">將函數視為無限維空間中的向量，並利用積分定義出「內積」來判斷它們是否垂直（正交）。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$\langle f, g \rangle = \int_{a}^{b} f(t) \overline{g(t)} \, dt = 0$$
                                    </div>
                                </div>
                                <button onclick="openLesson(1, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                    <!-- Lesson 2 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-blue-400 mb-4">LESSON 02</div>
                                <h3 class="text-2xl font-bold mb-2">從泰勒到傅立葉</h3>
                                <p class="text-sm text-gray-400 mt-2">Fourier Series</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">波動逼近的轉折</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-4">將週期性波形分解為無窮多個正弦波的疊加，並利用歐拉公式將其統整為優美的複數指數形式。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$f(t) = \sum_{n=-\infty}^{\infty} c_n e^{i n \omega_0 t}$$
                                    </div>
                                </div>
                                <button onclick="openLesson(2, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Phase 2 -->
            <div class="max-w-6xl mx-auto mb-16">
                <div class="flex items-center gap-4 mb-8 border-b border-white/10 pb-4">
                    <span class="text-4xl font-thin text-white/20">02</span>
                    <div>
                        <h3 class="text-lg font-bold text-white tracking-widest">連續變換與分析</h3>
                        <p class="text-xs text-gray-500 font-mono">核心理論 (Core Theory)</p>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Lesson 3 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-purple-400 mb-4">LESSON 03</div>
                                <h3 class="text-xl font-bold mb-2">連續傅立葉變換</h3>
                                <p class="text-xs text-gray-400">CFT</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">穿梭時域與頻域</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-2">將週期推向無窮大，處理非週期訊號。透過積分變換在兩個宇宙間穿梭。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-i\omega t} dt$$
                                    </div>
                                </div>
                                <button onclick="openLesson(3, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                    <!-- Lesson 4 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-purple-400 mb-4">LESSON 04</div>
                                <h3 class="text-xl font-bold mb-2">卷積定理與系統</h3>
                                <p class="text-xs text-gray-400">Convolution & LTI</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">最強大的數學工具</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-2">揭示「時域卷積等於頻域相乘」。將微積分運算簡化為代數乘法。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$\mathcal{F}\{(f * g)(t)\} = F(\omega) \cdot G(\omega)$$
                                    </div>
                                </div>
                                <button onclick="openLesson(4, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                    <!-- Lesson 5 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-purple-400 mb-4">LESSON 05</div>
                                <h3 class="text-xl font-bold mb-2">能量守恆與廣義函數</h3>
                                <p class="text-xs text-gray-400">Energy & Distributions</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">帕塞瓦爾定理</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-2">證明能量守恆，並引入狄拉克 $\delta$ 函數來處理奇異點。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$\int |f(t)|^2 dt = \frac{1}{2\pi} \int |F(\omega)|^2 d\omega$$
                                    </div>
                                </div>
                                <button onclick="openLesson(5, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Phase 3 -->
            <div class="max-w-6xl mx-auto mb-16">
                <div class="flex items-center gap-4 mb-8 border-b border-white/10 pb-4">
                    <span class="text-4xl font-thin text-white/20">03</span>
                    <div>
                        <h3 class="text-lg font-bold text-white tracking-widest">離散世界與演算法</h3>
                        <p class="text-xs text-gray-500 font-mono">現代應用 (Modern Applications)</p>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Lesson 6 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-green-400 mb-4">LESSON 06</div>
                                <h3 class="text-xl font-bold mb-2">取樣定理</h3>
                                <p class="text-xs text-gray-400">Sampling Theorem</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">從類比到數位</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-2">奈奎斯特定理：只有採樣頻率夠快，才能完美重建原始資訊而不發生混疊。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$f_s > 2 f_{\max}$$
                                    </div>
                                </div>
                                <button onclick="openLesson(6, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                    <!-- Lesson 7 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-green-400 mb-4">LESSON 07</div>
                                <h3 class="text-xl font-bold mb-2">DFT 與 FFT</h3>
                                <p class="text-xs text-gray-400">DFT & FFT</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">數位訊號處理引擎</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-2">利用單位根的對稱性將計算複雜度從 $O(N^2)$ 降至 $O(N \log N)$。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$X_k = \sum x_n e^{-i \frac{2\pi}{N} k n}$$
                                    </div>
                                </div>
                                <button onclick="openLesson(7, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                    <!-- Lesson 8 -->
                    <div class="flip-card" onclick="flipCard(this)">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="text-sm font-mono text-green-400 mb-4">LESSON 08</div>
                                <h3 class="text-xl font-bold mb-2">不確定性原理</h3>
                                <p class="text-xs text-gray-400">Beyond Fourier</p>
                                <div class="mt-auto pt-4 border-t border-white/10 text-xs text-gray-500">現代擴展</div>
                            </div>
                            <div class="flip-card-back">
                                <div>
                                    <h4 class="text-sm font-bold text-white mb-2">簡介</h4>
                                    <p class="text-xs text-gray-300 leading-relaxed mb-2">傅立葉變換的物理極限：無法同時精確捕捉訊號的時間位置與頻率分佈。</p>
                                    <div class="text-xs text-white bg-white/5 p-2 rounded text-center">
                                        $$\sigma_t \cdot \sigma_\omega \ge \frac{1}{2}$$
                                    </div>
                                </div>
                                <button onclick="openLesson(8, event)" class="btn-learn">深入學習 ➜</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </section>

    <!-- PAGE 3: STUDIO -->
    <section id="page-studio" class="page">
        <canvas id="canvas-trail" class="canvas-layer"></canvas>
        <canvas id="canvas-draw" class="canvas-layer"></canvas>

        <div class="absolute top-24 right-8 glass-panel rounded-xl p-6 w-80 flex flex-col gap-6 transition-opacity duration-300 hover:opacity-100 opacity-90 z-50">
            <div>
                <label class="text-[10px] font-bold text-gray-500 tracking-widest block mb-3">TOOLS</label>
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="resetCanvas()" class="py-3 border border-red-500/30 text-red-400 text-xs tracking-widest hover:bg-red-500/10 transition rounded">RESET</button>
                    <label class="py-3 border border-white/20 text-white text-xs tracking-widest hover:bg-white/10 transition rounded text-center cursor-pointer bg-white/5">
                        UPLOAD IMG
                        <input type="file" accept="image/*" onchange="processImage(this)" class="hidden">
                    </label>
                </div>
            </div>
            <div class="p-4 bg-white/5 rounded border border-white/10">
                <h3 class="text-xs font-bold text-white mb-1">STATUS</h3>
                <p id="status-msg" class="text-[10px] text-gray-400 leading-relaxed font-mono">Waiting for input...</p>
            </div>
            <div>
                <div class="flex justify-between text-[10px] text-gray-500 mb-2 items-center">
                    <span>SPEED (0.001 - 1000)</span>
                </div>
                <div class="flex items-center gap-2">
                    <input type="number" id="speed-input" class="w-full p-2 text-sm rounded" min="0.001" max="1000" step="0.1" value="1">
                </div>
            </div>
        </div>
    </section>

    <script>
        // --- Core State ---
        const state = {
            page: 'home',
            waveType: 'square', waveN: 5, time: 0, wavePath: [],
            drawing: false, path: [], fourierX: [], drawTime: 0, drawSpeed: 1,
            origin: {x: 0, y: 0}, isImageMode: false, lastPoint: null, historyPaths: [] 
        };

        // --- Detailed Course Content (Modal) ---
        const lessons = {
            1: {
                title: "函數空間與正交性",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>打破「函數」與「向量」的界線。將函數視為無限維空間中的向量。</p>
                        <h3>1. 向量空間的回顧</h3>
                        <p>我們熟悉的三維向量空間 $\\mathbb{R}^3$ 由基底（Basis）組成。任何向量 $\\mathbf{v}$ 都可以表示為基底的線性組合。函數空間也是如此。</p>
                        <h3>2. 內積的推廣</h3>
                        <p>從 $\\mathbf{u} \\cdot \\mathbf{v}$ 到函數內積：</p>
                        <div class="math-block">$$\\langle f, g \\rangle = \\int_{a}^{b} f(t) \\overline{g(t)} \\, dt$$</div>
                        <p>若兩個函數的內積為 0，我們稱這兩個函數<strong>正交 (Orthogonal)</strong>。</p>
                        <h3>3. 正交函數集</h3>
                        <p>為什麼選擇三角函數？因為三角函數系 $\\{1, \\cos(nt), \\sin(nt)\\}$ 是正交的。這意味著我們可以像用座標表示向量一樣，用一組係數來唯一表示一個函數。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>希爾伯特空間 (Hilbert Space)、柯西-施瓦茨不等式。</p></div>
                    </div>`
            },
            2: {
                title: "從泰勒級數到傅立葉級數",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>週期性函數的分解。從「多項式逼近」（Taylor）轉向「波動逼近」（Fourier）。</p>
                        <h3>1. 三角形式的傅立葉級數</h3>
                        <p>三角形式是最初步的表達。</p>
                        <h3>2. 歐拉公式的引入</h3>
                        <p>利用 $e^{ix} = \\cos x + i \\sin x$ 將級數簡化為複數指數形式：</p>
                        <div class="math-block">$$f(t) = \\sum_{n=-\\infty}^{\\infty} c_n e^{in\\omega_0 t}$$</div>
                        <h3>3. 收斂性討論</h3>
                        <p>狄利克雷條件與吉布斯現象 (Gibbs Phenomenon)。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>複數平面幾何、均方收斂。</p></div>
                    </div>`
            },
            3: {
                title: "連續傅立葉變換 (CFT)",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>處理「非週期」訊號。將週期 $T$ 推向無窮大。</p>
                        <h3>1. 傅立葉積分</h3>
                        <p>頻譜從「離散」變為「連續」。</p>
                        <h3>2. 變換對定義</h3>
                        <div class="math-block">$$\\mathcal{F}\\{f(t)\\} = F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$$</div>
                        <h3>3. 對偶性 (Duality)</h3>
                        <p>時域與頻域的對稱之美（矩形波 $\\leftrightarrow$ Sinc 函數）。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>積分變換、黎曼-勒貝格引理。</p></div>
                    </div>`
            },
            4: {
                title: "卷積定理與系統理論",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>為什麼「時域卷積」等於「頻域相乘」？</p>
                        <h3>1. 卷積 (Convolution) 的物理意義</h3>
                        <p>翻轉、平移、積分。描述系統對輸入的響應。</p>
                        <h3>2. 線性非時變系統 (LTI)</h3>
                        <p>輸出等於輸入與脈衝響應的卷積。</p>
                        <h3>3. 卷積定理</h3>
                        <div class="math-block">$$\\mathcal{F}\\{f(t) * g(t)\\} = F(\\omega) \\cdot G(\\omega)$$</div>
                        <p>利用卷積定理求解微分方程。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>格林函數 (Green's Function)。</p></div>
                    </div>`
            },
            5: {
                title: "能量守恆與廣義函數",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>處理數學上「不乖」的函數。</p>
                        <h3>1. 帕塞瓦爾定理</h3>
                        <div class="math-block">$$\\int_{-\\infty}^{\\infty} |f(t)|^2 dt = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} |F(\\omega)|^2 d\\omega$$</div>
                        <p>能量守恆的數學表達。</p>
                        <h3>2. 狄拉克 $\\delta$ 函數</h3>
                        <p>它不是函數，是分佈。用於廣義傅立葉變換。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>廣義函數論、Plancherel 定理。</p></div>
                    </div>`
            },
            6: {
                title: "取樣定理與離散化",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>從類比通往數位的橋樑。</p>
                        <h3>1. 狄拉克梳狀函數</h3>
                        <p>取樣即乘上一串脈衝。</p>
                        <h3>2. 奈奎斯特-香農取樣定理</h3>
                        <div class="math-block">$$f_s > 2 f_{\\max}$$</div>
                        <p>取樣頻率必須大於兩倍最高頻率。</p>
                        <h3>3. 混疊現象 (Aliasing)</h3>
                        <p>頻率的「偽裝」與濾波。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>頻譜複製、帶限訊號。</p></div>
                    </div>`
            },
            7: {
                title: "DFT 與 FFT 演算法",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>電腦如何實際計算頻譜？</p>
                        <h3>1. 從 DTFT 到 DFT</h3>
                        <p>頻譜的離散化。</p>
                        <h3>2. DFT 的矩陣形式</h3>
                        <div class="math-block">$$X_k = \\sum_{n=0}^{N-1} x_n e^{-i \\frac{2\\pi}{N} k n}$$</div>
                        <h3>3. 快速傅立葉變換 (FFT)</h3>
                        <p>Cooley-Tukey 演算法，將複雜度降至 $O(N \\log N)$。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>分治法、范德蒙矩陣。</p></div>
                    </div>`
            },
            8: {
                title: "不確定性原理與現代擴展",
                content: `
                    <div class="lesson-body">
                        <p><strong>核心概念：</strong>傅立葉變換的極限。</p>
                        <h3>1. 海森堡不確定性原理</h3>
                        <div class="math-block">$$\\sigma_t \\cdot \\sigma_\\omega \\ge \\frac{1}{2}$$</div>
                        <p>無法同時精確知道時間與頻率。</p>
                        <h3>2. 短時距傅立葉變換 (STFT)</h3>
                        <p>頻譜圖 (Spectrogram)。</p>
                        <h3>3. 小波變換 (Wavelet)</h3>
                        <p>解決多解析度問題。</p>
                        <div class="highlight"><p><strong>關鍵數學：</strong>時頻分析。</p></div>
                    </div>`
            }
        };

        // --- Navigation & UI ---
        function showPage(pageId) {
            state.page = pageId;
            document.querySelectorAll('.page').forEach(p => {
                p.classList.remove('active');
                if(p.id === 'page-knowledge' && pageId !== 'knowledge') p.scrollTop = 0;
            });
            document.getElementById('page-' + pageId).classList.add('active');
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.getElementById('nav-' + pageId).classList.add('active');
            if(pageId === 'studio') resize();
            // Auto-render math when knowledge page opens
            if(pageId === 'knowledge' && window.MathJax) {
                setTimeout(() => MathJax.typesetPromise(), 50);
            }
        }

        function flipCard(card) {
            // Ensure math is rendered on back face
            if(window.MathJax && !card.classList.contains('flipped')) {
                MathJax.typesetPromise([card.querySelector('.flip-card-back')]);
            }
            card.classList.toggle('flipped');
        }

        function openLesson(id, event) {
            event.stopPropagation();
            const modal = document.getElementById('lesson-modal');
            const content = document.getElementById('lesson-body');
            const data = lessons[id];
            content.innerHTML = `
                <h2 class="text-3xl font-bold text-white mb-2">${data.title}</h2>
                <div class="h-1 w-20 bg-blue-500 mb-8"></div>
                ${data.content}
            `;
            modal.classList.add('open');
            if(window.MathJax) MathJax.typesetPromise([content]);
        }

        function closeLesson() {
            document.getElementById('lesson-modal').classList.remove('open');
        }
        document.getElementById('lesson-modal').addEventListener('click', (e) => {
            if(e.target.id === 'lesson-modal') closeLesson();
        });

        // --- DFT & V7.0 Logic ---
        function dft(x) {
            const X = []; const N = x.length;
            for (let k = 0; k < N; k++) {
                let re = 0, im = 0;
                for (let n = 0; n < N; n++) {
                    const phi = (2 * Math.PI * k * n) / N;
                    re += x[n].x * Math.cos(phi) + x[n].y * Math.sin(phi);
                    im += x[n].y * Math.cos(phi) - x[n].x * Math.sin(phi);
                }
                re = re / N; im = im / N;
                let freq = k; if (k > N / 2) freq = k - N;
                let amp = Math.sqrt(re * re + im * im);
                let phase = Math.atan2(im, re);
                X[k] = { re, im, freq, amp, phase };
            }
            return X;
        }

        const canvasWave = document.getElementById('canvas-wave');
        const ctxWave = canvasWave.getContext('2d');
        const canvasDraw = document.getElementById('canvas-draw');
        const ctxDraw = canvasDraw.getContext('2d');
        const canvasTrail = document.getElementById('canvas-trail');
        const ctxTrail = canvasTrail.getContext('2d');

        function resize() {
            const w = window.innerWidth; const h = window.innerHeight;
            canvasWave.width = w; canvasWave.height = h;
            canvasDraw.width = w; canvasDraw.height = h;
            canvasTrail.width = w; canvasTrail.height = h;
            state.origin = { x: w/2, y: h/2 };
        }
        window.addEventListener('resize', resize);
        resize();

        const statusMsg = document.getElementById('status-msg');
        canvasDraw.addEventListener('mousedown', startDrawing);
        canvasDraw.addEventListener('mousemove', makeDrawing);
        canvasDraw.addEventListener('mouseup', endDrawing);
        canvasDraw.addEventListener('touchstart', e => { e.preventDefault(); startDrawing(e.touches[0]); });
        canvasDraw.addEventListener('touchmove', e => { e.preventDefault(); makeDrawing(e.touches[0]); });
        canvasDraw.addEventListener('touchend', endDrawing);

        function startDrawing(e) {
            state.drawing = true; state.isImageMode = false;
            state.path = []; state.fourierX = []; state.historyPaths = [];
            ctxTrail.clearRect(0, 0, canvasTrail.width, canvasTrail.height);
            state.lastPoint = null; state.origin = {x: 0, y: 0};
            statusMsg.innerText = "Recording...";
        }
        function makeDrawing(e) {
            if (!state.drawing) return;
            state.path.push({ x: e.clientX, y: e.clientY });
            if (state.path.length > 1) {
                const last = state.path[state.path.length-2]; const curr = state.path[state.path.length-1];
                ctxTrail.beginPath(); ctxTrail.strokeStyle = "#555"; ctxTrail.lineWidth = 2;
                ctxTrail.moveTo(last.x, last.y); ctxTrail.lineTo(curr.x, curr.y); ctxTrail.stroke();
            }
        }
        function endDrawing() {
            if (!state.drawing) return;
            state.drawing = false;
            ctxTrail.clearRect(0, 0, canvasTrail.width, canvasTrail.height);
            calculateFourier(1);
        }

        window.processImage = function(input) {
            if (!input.files || !input.files[0]) return;
            statusMsg.innerText = "Scanning...";
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const tempC = document.createElement('canvas');
                    const scale = 600 / Math.max(img.width, img.height); 
                    const w = Math.floor(img.width * scale); const h = Math.floor(img.height * scale);
                    tempC.width = w; tempC.height = h;
                    const tCtx = tempC.getContext('2d');
                    tCtx.drawImage(img, 0, 0, w, h);
                    const data = tCtx.getImageData(0, 0, w, h).data;
                    const getVal = (x, y) => {
                        if (x < 0 || y < 0 || x >= w || y >= h) return 0;
                        const i = (y * w + x) * 4;
                        return (data[i] + data[i+1] + data[i+2]) / 3;
                    };
                    const edgeMap = new Uint8Array(w * h); const edges = [];
                    for (let y = 1; y < h - 1; y++) {
                        for (let x = 1; x < w - 1; x++) {
                            const gx = -getVal(x-1, y-1) + getVal(x+1, y-1) + -2*getVal(x-1, y) + 2*getVal(x+1, y) + -getVal(x-1, y+1) + getVal(x+1, y+1);
                            const gy = -getVal(x-1, y-1) - 2*getVal(x, y-1) - getVal(x+1, y-1) + getVal(x-1, y+1) + 2*getVal(x, y+1) + getVal(x+1, y+1);
                            if (Math.sqrt(gx*gx + gy*gy) > 45) { edgeMap[y * w + x] = 1; edges.push({x, y}); }
                        }
                    }
                    if (edges.length < 10) { statusMsg.innerText = "No edges found."; return; }
                    statusMsg.innerText = "Linking Segments...";
                    setTimeout(() => {
                        const visited = new Uint8Array(w * h); const allSegments = [];
                        for (let i = 0; i < edges.length; i++) {
                            const startPt = edges[i]; const idx = startPt.y * w + startPt.x;
                            if (visited[idx]) continue;
                            let currentPath = []; let stack = [startPt]; visited[idx] = 1;
                            while (stack.length > 0) {
                                const pt = stack.pop(); currentPath.push(pt);
                                const neighbors = [];
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const nx = pt.x + dx; const ny = pt.y + dy; const nIdx = ny * w + nx;
                                        if (nx >= 0 && nx < w && ny >= 0 && ny < h && edgeMap[nIdx] === 1 && !visited[nIdx]) {
                                            neighbors.push({x: nx, y: ny, idx: nIdx});
                                        }
                                    }
                                }
                                if (neighbors.length > 0) { const next = neighbors[0]; visited[next.idx] = 1; stack.push(next); }
                            }
                            if (currentPath.length > 15) allSegments.push(currentPath);
                        }
                        if (allSegments.length === 0) { statusMsg.innerText = "No valid contours."; return; }
                        allSegments.sort((a, b) => b.length - a.length);
                        let finalPath = allSegments[0];
                        const usedSegments = new Uint8Array(allSegments.length); usedSegments[0] = 1;
                        for (let k = 1; k < allSegments.length; k++) {
                            let bestIdx = -1; let minInfo = { dist: Infinity, reverse: false };
                            const tail = finalPath[finalPath.length - 1];
                            for (let j = 1; j < allSegments.length; j++) {
                                if (usedSegments[j]) continue;
                                const seg = allSegments[j]; const head = seg[0]; const segTail = seg[seg.length - 1];
                                const d1 = (tail.x - head.x)**2 + (tail.y - head.y)**2;
                                const d2 = (tail.x - segTail.x)**2 + (tail.y - segTail.y)**2;
                                if (d1 < minInfo.dist) { minInfo = { dist: d1, reverse: false }; bestIdx = j; }
                                if (d2 < minInfo.dist) { minInfo = { dist: d2, reverse: true }; bestIdx = j; }
                            }
                            if (bestIdx !== -1) {
                                usedSegments[bestIdx] = 1; let nextSeg = allSegments[bestIdx];
                                if (minInfo.reverse) nextSeg = nextSeg.slice().reverse();
                                finalPath = finalPath.concat(nextSeg);
                            } else { break; }
                        }
                        const smoothed = []; const windowSize = 2;
                        for(let i=0; i<finalPath.length; i++) {
                            let sumX = 0, sumY = 0, n = 0;
                            for(let j = -windowSize; j <= windowSize; j++) {
                                let idx = i + j;
                                if (idx >= 0 && idx < finalPath.length) { sumX += finalPath[idx].x; sumY += finalPath[idx].y; n++; }
                            }
                            smoothed.push({x: sumX/n, y: sumY/n});
                        }
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        for(let p of smoothed) { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); }
                        const contentW = maxX - minX; const contentH = maxY - minY;
                        const screenScale = Math.min(canvasDraw.width * 0.7, canvasDraw.height * 0.7) / Math.max(contentW, contentH);
                        const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2;
                        state.path = smoothed.map(p => ({ x: (p.x - centerX) * screenScale, y: (p.y - centerY) * screenScale }));
                        state.isImageMode = true; state.origin = { x: canvasDraw.width/2, y: canvasDraw.height/2 };
                        ctxTrail.clearRect(0, 0, canvasTrail.width, canvasTrail.height);
                        state.lastPoint = null; state.historyPaths = [];
                        const targetPoints = 3000; 
                        if (state.path.length > targetPoints) {
                            const step = Math.ceil(state.path.length / targetPoints);
                            state.path = state.path.filter((_, i) => i % step === 0);
                        }
                        calculateFourier(1);
                    }, 50);
                }
                img.src = e.target.result;
            }
            reader.readAsDataURL(input.files[0]);
        }

        function calculateFourier(skip) {
            statusMsg.innerText = "Computing DFT...";
            const sampled = [];
            for(let i=0; i<state.path.length; i+=skip) sampled.push(state.path[i]);
            state.fourierX = dft(sampled);
            if (state.isImageMode) { state.fourierX[0].re = 0; state.fourierX[0].im = 0; }
            state.fourierX.sort((a, b) => b.amp - a.amp);
            state.drawTime = 0; state.lastPoint = null; state.currentDrawingBuffer = [];
            statusMsg.innerText = `Drawing (${state.fourierX.length} cycles)`;
        }

        function drawWaveLoop() {
            if(state.page !== 'home') return;
            ctxWave.fillStyle = "#050505"; ctxWave.fillRect(0, 0, canvasWave.width, canvasWave.height);
            let cx = canvasWave.width < 768 ? canvasWave.width / 2 : canvasWave.width * 0.3;
            let cy = canvasWave.height / 2; let x = cx, y = cy;
            for (let i = 0; i < state.waveN; i++) {
                let prevX = x, prevY = y; let n, radius;
                if (state.waveType === 'square') { n = i * 2 + 1; radius = 100 * (4 / (n * Math.PI)); }
                else if (state.waveType === 'sawtooth') { n = i + 1; radius = 100 * (2 / (n * Math.PI)) * (i % 2 === 0 ? 1 : -1); }
                else { n = i * 2 + 1; radius = 100 * (8 / (Math.PI * Math.PI * n * n)) * (i % 2 === 0 ? 1 : -1); }
                x += radius * Math.cos(n * state.time); y += radius * Math.sin(n * state.time);
                ctxWave.beginPath(); ctxWave.strokeStyle = "rgba(255,255,255,0.15)"; ctxWave.arc(prevX, prevY, Math.abs(radius), 0, Math.PI * 2); ctxWave.stroke();
                if (i < 20) { ctxWave.beginPath(); ctxWave.strokeStyle = "rgba(255,255,255,0.3)"; ctxWave.moveTo(prevX, prevY); ctxWave.lineTo(x, y); ctxWave.stroke(); }
            }
            let offset = 200; state.wavePath.unshift(y); if(state.wavePath.length > 1000) state.wavePath.pop();
            ctxWave.beginPath(); ctxWave.strokeStyle = "rgba(255,255,255,0.1)"; ctxWave.moveTo(x, y); ctxWave.lineTo(cx + offset, y); ctxWave.stroke();
            ctxWave.beginPath(); ctxWave.strokeStyle = "#fff"; ctxWave.lineWidth = 2; ctxWave.moveTo(cx + offset, state.wavePath[0]);
            for(let i=1; i<state.wavePath.length; i++) ctxWave.lineTo(cx + offset + i, state.wavePath[i]); ctxWave.stroke();
            state.time -= 0.02;
        }

        function drawStudioLoop() {
            if(state.page !== 'studio') return;
            ctxDraw.clearRect(0, 0, canvasDraw.width, canvasDraw.height);
            ctxTrail.clearRect(0, 0, canvasTrail.width, canvasTrail.height);

            if (state.historyPaths && state.historyPaths.length > 0) {
                for (let i = 0; i < state.historyPaths.length; i++) {
                    const h = state.historyPaths[i];
                    if (h.points.length < 2) continue;
                    ctxTrail.beginPath(); ctxTrail.strokeStyle = `rgba(255, 255, 255, ${h.opacity})`; ctxTrail.lineWidth = 2.5; ctxTrail.lineCap = "round";
                    ctxTrail.moveTo(h.points[0].x, h.points[0].y);
                    for (let k = 1; k < h.points.length; k++) ctxTrail.lineTo(h.points[k].x, h.points[k].y);
                    ctxTrail.stroke();
                    h.opacity -= 0.005;
                }
                state.historyPaths = state.historyPaths.filter(h => h.opacity > 0);
            }

            if (state.path.length > 0) {
                ctxDraw.beginPath(); ctxDraw.strokeStyle = "rgba(255, 255, 255, 0.05)"; ctxDraw.lineWidth = 2;
                const startX = state.isImageMode ? state.origin.x : 0; const startY = state.isImageMode ? state.origin.y : 0;
                ctxDraw.moveTo(startX + state.path[0].x, startY + state.path[0].y);
                for(let p of state.path) ctxDraw.lineTo(startX + p.x, startY + p.y); ctxDraw.stroke();
            }

            if (state.fourierX.length > 0) {
                let x = state.origin.x; let y = state.origin.y;
                for (let i = 0; i < state.fourierX.length; i++) {
                    let prevX = x, prevY = y;
                    let freq = state.fourierX[i].freq; let radius = state.fourierX[i].amp; let phase = state.fourierX[i].phase;
                    x += radius * Math.cos(freq * state.drawTime + phase); y += radius * Math.sin(freq * state.drawTime + phase);
                    if (radius > 0.5) {
                        ctxDraw.beginPath(); ctxDraw.strokeStyle = "rgba(255, 255, 255, 0.3)"; ctxDraw.lineWidth = 1; ctxDraw.arc(prevX, prevY, radius, 0, Math.PI * 2); ctxDraw.stroke();
                        ctxDraw.beginPath(); ctxDraw.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctxDraw.lineWidth = 1.5; ctxDraw.moveTo(prevX, prevY); ctxDraw.lineTo(x, y); ctxDraw.stroke();
                    }
                }
                if (!state.currentDrawingBuffer) state.currentDrawingBuffer = [];
                if (state.lastPoint) {
                    const dist = Math.hypot(x - state.lastPoint.x, y - state.lastPoint.y);
                    const jumpThreshold = 2 + state.drawSpeed * 3; 
                    if (dist <= jumpThreshold) { state.currentDrawingBuffer.push({x, y}); } 
                    else { state.currentDrawingBuffer.push({x, y}); }
                    ctxTrail.beginPath(); ctxTrail.strokeStyle = `rgba(255, 255, 255, 1)`; ctxTrail.lineWidth = 2.5; ctxTrail.lineCap = "round";
                    ctxTrail.moveTo(state.lastPoint.x, state.lastPoint.y); ctxTrail.lineTo(x, y); ctxTrail.stroke();
                }
                state.lastPoint = {x, y};
                const dt = (2 * Math.PI / state.fourierX.length); state.drawTime += dt * state.drawSpeed;
                if (state.drawTime > 2 * Math.PI) {
                    state.drawTime = 0; state.lastPoint = null;
                    if (state.currentDrawingBuffer.length > 0) {
                        state.historyPaths.push({ points: [...state.currentDrawingBuffer], opacity: 1.0 });
                        state.currentDrawingBuffer = [];
                    }
                    ctxTrail.clearRect(0, 0, canvasTrail.width, canvasTrail.height);
                }
            }
        }

        document.getElementById('wave-slider').addEventListener('input', e => { state.waveN = parseInt(e.target.value); document.getElementById('wave-n-display').innerText = state.waveN; state.wavePath = []; });
        const speedInput = document.getElementById('speed-input');
        speedInput.addEventListener('input', e => { let val = parseFloat(e.target.value); if(isNaN(val)) val = 1; if(val < 0.001) val = 0.001; if(val > 1000) val = 1000; state.drawSpeed = val; });
        window.setWaveType = type => { state.waveType = type; state.wavePath = []; };
        window.resetCanvas = () => { 
            state.path = []; state.fourierX = []; state.lastPoint = null; state.drawTime = 0; state.historyPaths = [];
            statusMsg.innerText = "Ready"; ctxDraw.clearRect(0,0,canvasDraw.width, canvasDraw.height); ctxTrail.clearRect(0,0,canvasTrail.width, canvasTrail.height);
        };
        function animate() { if (state.page === 'home') drawWaveLoop(); else drawStudioLoop(); requestAnimationFrame(animate); }
        animate();
    </script>
</body>
</html>